generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// ==================== Authentication Models ====================

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  password      String?
  image         String?
  role          String    @default("USER") // USER, ADMIN
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Password reset
  resetToken       String?
  resetTokenExpiry DateTime?

  accounts Account[]
  sessions Session[]
  apiKeys  ApiKey[]
  tunnels  Tunnel[]

  // Team relationships
  ownedTeams      Team[]           @relation("TeamOwner")
  teamMemberships TeamMember[]
  sentInvitations TeamInvitation[]

  // Security relationships
  rateLimitRules RateLimitRule[]
  geoRules       GeoRule[]
  auditLogs      AuditLog[]

  // Health check relationships
  healthChecks HealthCheck[]

  // FCM tokens for push notifications
  fcmTokens FcmToken[]

  // Payment relationships
  subscription   Subscription?
  payments       Payment[]
  paymentMethods PaymentMethod[]
  invoices       Invoice[]

  @@index([email])
  @@index([resetToken])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ==================== Team Models ====================

model Team {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  description String?
  image       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  ownerId String
  owner   User   @relation("TeamOwner", fields: [ownerId], references: [id])

  members     TeamMember[]
  invitations TeamInvitation[]
  tunnels     Tunnel[]

  @@index([slug])
  @@index([ownerId])
}

model TeamMember {
  id        String   @id @default(cuid())
  role      String   @default("MEMBER") // OWNER, ADMIN, MEMBER
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  teamId String
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([teamId, userId])
  @@index([teamId])
  @@index([userId])
}

model TeamInvitation {
  id        String   @id @default(cuid())
  email     String
  role      String   @default("MEMBER")
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  teamId String
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  invitedById String
  invitedBy   User   @relation(fields: [invitedById], references: [id])

  @@index([teamId])
  @@index([email])
  @@index([token])
}

// ==================== Application Models ====================

model Tunnel {
  id          String    @id @default(cuid())
  subdomain   String    @unique
  localPort   Int
  localHost   String    @default("localhost")

  protocol    String    @default("HTTP")
  password    String?
  ipWhitelist String?

  isActive    Boolean   @default(true)
  expiresAt   DateTime?
  inspect     Boolean   @default(true)

  totalRequests Int     @default(0)
  totalBytes    BigInt  @default(0)

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  lastActiveAt DateTime @default(now())

  // User association (optional for backward compatibility)
  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Team association (optional)
  teamId String?
  team   Team?   @relation(fields: [teamId], references: [id], onDelete: SetNull)

  requests Request[]

  // Security relationships
  rateLimitRules RateLimitRule[]
  geoRules       GeoRule[]

  // Encryption relationships
  encryptionKey     EncryptionKey?
  tunnelEncryption  TunnelEncryption?

  // Health check relationships
  healthChecks HealthCheck[]

  @@index([subdomain])
  @@index([isActive])
  @@index([userId])
  @@index([teamId])
  @@index([lastActiveAt])        // For cleanup and activity sorting
  @@index([isActive, lastActiveAt]) // For active tunnel queries with sorting
}

model Request {
  id       String @id @default(cuid())
  tunnelId String
  tunnel   Tunnel @relation(fields: [tunnelId], references: [id], onDelete: Cascade)

  method  String
  path    String
  headers String
  body    String?
  query   String?

  statusCode      Int?
  responseHeaders String?
  responseBody    String?
  responseTime    Int?

  ip        String?
  userAgent String?

  createdAt DateTime @default(now())

  @@index([tunnelId])
  @@index([createdAt])
  @@index([tunnelId, createdAt]) // Composite index for filtered queries
  @@index([statusCode])          // For status code filtering
  @@index([method])              // For method-based analytics grouping
  @@index([ip])                  // For unique IP analytics
}

model Settings {
  id String @id @default("default")

  // General
  defaultPort       Int     @default(3000)
  defaultSubdomain  String  @default("")
  autoReconnect     Boolean @default(true)
  keepHistory       Int     @default(7)
  maxRequests       Int     @default(1000)

  // Security
  requirePassword     Boolean @default(false)
  defaultExpiration   String  @default("never")
  rateLimit           Int     @default(100)

  updatedAt DateTime @updatedAt
}

model ApiKey {
  id        String    @id @default(cuid())
  name      String
  key       String    @unique
  keyPrefix String    @default("") // First 8 chars for display

  isActive   Boolean   @default(true)
  expiresAt  DateTime?
  createdAt  DateTime  @default(now())
  lastUsedAt DateTime?

  // User association
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([key])
  @@index([userId])
}

// ==================== Security Models ====================

model RateLimitRule {
  id      String  @id @default(cuid())
  name    String
  enabled Boolean @default(true)

  // Rate limit settings
  requestsPerMinute Int @default(60)
  requestsPerHour   Int @default(1000)
  burstLimit        Int @default(100)

  // Response when rate limited
  blockDuration Int     @default(60) // seconds
  customMessage String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Tunnel association (optional, null = global rule)
  tunnelId String?
  tunnel   Tunnel? @relation(fields: [tunnelId], references: [id], onDelete: Cascade)

  // User association
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([tunnelId])
  @@index([userId])
}

model GeoRule {
  id      String  @id @default(cuid())
  name    String
  enabled Boolean @default(true)

  // Geo settings
  mode      String @default("ALLOW") // ALLOW or BLOCK
  countries String // Comma-separated country codes (US,UK,DE)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Tunnel association (optional, null = global rule)
  tunnelId String?
  tunnel   Tunnel? @relation(fields: [tunnelId], references: [id], onDelete: Cascade)

  // User association
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([tunnelId])
  @@index([userId])
}

model AuditLog {
  id String @id @default(cuid())

  // Event details
  action     String // LOGIN, LOGOUT, CREATE_TUNNEL, DELETE_TUNNEL, etc.
  resource   String // TUNNEL, TEAM, USER, API_KEY, etc.
  resourceId String?

  // Event context
  ipAddress String?
  userAgent String?
  country   String?
  city      String?

  // Event data
  details String? // JSON data
  status  String  @default("SUCCESS") // SUCCESS, FAILURE

  createdAt DateTime @default(now())

  // User association
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([action])
  @@index([resource])
  @@index([createdAt])
  @@index([userId, createdAt]) // Composite index for user audit history
}

model RateLimitHit {
  id String @id @default(cuid())

  ipAddress   String
  tunnelId    String?
  count       Int      @default(1)
  windowStart DateTime @default(now())

  @@unique([ipAddress, tunnelId, windowStart])
  @@index([ipAddress])
  @@index([tunnelId])
  @@index([windowStart])
}

// ==================== Encryption Models ====================

model EncryptionKey {
  id         String    @id @default(cuid())
  publicKey  String    // RSA public key (PEM format)
  privateKey String    // RSA private key (encrypted with master key)
  algorithm  String    @default("RSA-2048")
  expiresAt  DateTime
  rotatedAt  DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  tunnelId String @unique
  tunnel   Tunnel @relation(fields: [tunnelId], references: [id], onDelete: Cascade)

  @@index([tunnelId])
  @@index([expiresAt])
}

model TunnelEncryption {
  id              String    @id @default(cuid())
  enabled         Boolean   @default(false)
  mode            String    @default("TRANSPORT") // E2E, TRANSPORT, NONE
  algorithm       String    @default("AES-256-GCM")
  keyRotationDays Int       @default(30)
  lastRotation    DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  tunnelId String @unique
  tunnel   Tunnel @relation(fields: [tunnelId], references: [id], onDelete: Cascade)

  @@index([tunnelId])
}

// ==================== Health Check Models ====================

model HealthCheck {
  id      String  @id @default(cuid())
  name    String
  type    String  // TUNNEL, HTTP, TCP, DATABASE
  target  String  // URL or identifier to check
  enabled Boolean @default(true)

  // Check configuration
  interval Int @default(60)  // seconds
  timeout  Int @default(30)  // seconds
  retries  Int @default(3)

  // Alert configuration
  alertOnFailure    Boolean @default(true)
  alertAfterRetries Int     @default(2)

  // Current status
  status           String    @default("UNKNOWN") // HEALTHY, UNHEALTHY, DEGRADED, UNKNOWN
  lastCheck        DateTime?
  lastSuccess      DateTime?
  lastFailure      DateTime?
  consecutiveFails Int       @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Tunnel association (optional)
  tunnelId String?
  tunnel   Tunnel? @relation(fields: [tunnelId], references: [id], onDelete: Cascade)

  // User association
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  results HealthCheckResult[]

  @@index([tunnelId])
  @@index([userId])
  @@index([status])
}

model HealthCheckResult {
  id           String   @id @default(cuid())
  status       String   // SUCCESS, FAILURE, TIMEOUT
  responseTime Int?     // milliseconds
  statusCode   Int?
  message      String?
  createdAt    DateTime @default(now())

  healthCheckId String
  healthCheck   HealthCheck @relation(fields: [healthCheckId], references: [id], onDelete: Cascade)

  @@index([healthCheckId])
  @@index([createdAt])
}

// ==================== Push Notification Models ====================

model FcmToken {
  id        String   @id @default(cuid())
  token     String   @unique
  platform  String   @default("WEB") // WEB, ANDROID, IOS
  deviceId  String?  // Optional device identifier

  // Notification preferences
  tunnelNotifications Boolean @default(true)
  requestNotifications Boolean @default(false)
  errorNotifications  Boolean @default(true)

  // Token metadata
  isActive  Boolean  @default(true)
  lastUsed  DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // User association
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([isActive])
}

// ==================== Subscription & Payment Models ====================

model Subscription {
  id                   String    @id @default(cuid())
  userId               String    @unique
  user                 User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Subscription details
  tier                 String    @default("free") // free, starter, pro, enterprise
  status               String    @default("active") // active, canceled, past_due, paused, trialing

  // Payment provider info
  provider             String?   // stripe, paymob, paytabs, paddle
  externalId           String?   // Subscription ID from provider
  externalCustomerId   String?   // Customer ID from provider

  // Billing period
  currentPeriodStart   DateTime?
  currentPeriodEnd     DateTime?
  cancelAtPeriodEnd    Boolean   @default(false)
  canceledAt           DateTime?

  // Trial
  trialStart           DateTime?
  trialEnd             DateTime?

  // Metadata
  metadata             String?   // JSON string for additional data

  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  @@index([status])
  @@index([provider])
  @@index([externalId])
}

model Payment {
  id                String    @id @default(cuid())
  userId            String
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Payment details
  amount            Int       // Amount in smallest currency unit (cents)
  currency          String    @default("USD")
  status            String    // pending, completed, failed, refunded, disputed

  // Provider info
  provider          String    // stripe, paymob, paytabs, paddle
  externalId        String?   // Payment/Transaction ID from provider
  paymentMethod     String?   // card, wallet, kiosk, etc.

  // Card info (if applicable)
  cardBrand         String?   // visa, mastercard, etc.
  cardLast4         String?

  // Invoice/Receipt
  invoiceId         String?
  receiptUrl        String?

  // Refund info
  refundedAmount    Int?
  refundedAt        DateTime?
  refundReason      String?

  // Metadata
  description       String?
  metadata          String?   // JSON string

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([userId])
  @@index([status])
  @@index([provider])
  @@index([externalId])
  @@index([createdAt])
}

model PaymentMethod {
  id                String    @id @default(cuid())
  userId            String
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Provider info
  provider          String    // stripe, paymob, paytabs, paddle
  externalId        String    // Payment method ID from provider

  // Method details
  type              String    // card, wallet, bank_account

  // Card details (if type = card)
  cardBrand         String?   // visa, mastercard, amex, etc.
  cardLast4         String?
  cardExpMonth      Int?
  cardExpYear       Int?
  cardCountry       String?

  // Wallet details (if type = wallet)
  walletType        String?   // vodafone_cash, orange, etisalat, apple_pay, google_pay
  walletPhone       String?

  // Status
  isDefault         Boolean   @default(false)
  isActive          Boolean   @default(true)

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@unique([provider, externalId])
  @@index([userId])
  @@index([provider])
}

model Invoice {
  id                String    @id @default(cuid())
  userId            String
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Invoice details
  invoiceNumber     String    @unique
  status            String    // draft, open, paid, void, uncollectible

  // Amounts
  subtotal          Int       // Before tax
  tax               Int       @default(0)
  total             Int       // After tax
  amountPaid        Int       @default(0)
  amountDue         Int
  currency          String    @default("USD")

  // Provider info
  provider          String?
  externalId        String?
  hostedInvoiceUrl  String?
  pdfUrl            String?

  // Dates
  dueDate           DateTime?
  paidAt            DateTime?

  // Line items stored as JSON
  lineItems         String?   // JSON array

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([userId])
  @@index([status])
  @@index([invoiceNumber])
}

model WebhookEvent {
  id                String    @id @default(cuid())
  provider          String    // stripe, paymob, paytabs, paddle
  eventType         String    // Event type from provider
  externalId        String    // Event ID from provider

  // Payload
  payload           String    // JSON string of full webhook payload

  // Processing status
  status            String    @default("pending") // pending, processed, failed
  processedAt       DateTime?
  error             String?
  retryCount        Int       @default(0)

  createdAt         DateTime  @default(now())

  @@unique([provider, externalId])
  @@index([provider])
  @@index([eventType])
  @@index([status])
  @@index([createdAt])
}
