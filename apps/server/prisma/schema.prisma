generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// ==================== Authentication Models ====================

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  password      String?
  image         String?
  role          String    @default("USER") // USER, ADMIN
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts Account[]
  sessions Session[]
  apiKeys  ApiKey[]
  tunnels  Tunnel[]

  // Team relationships
  ownedTeams      Team[]           @relation("TeamOwner")
  teamMemberships TeamMember[]
  sentInvitations TeamInvitation[]

  @@index([email])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ==================== Team Models ====================

model Team {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  description String?
  image       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  ownerId String
  owner   User   @relation("TeamOwner", fields: [ownerId], references: [id])

  members     TeamMember[]
  invitations TeamInvitation[]
  tunnels     Tunnel[]

  @@index([slug])
  @@index([ownerId])
}

model TeamMember {
  id        String   @id @default(cuid())
  role      String   @default("MEMBER") // OWNER, ADMIN, MEMBER
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  teamId String
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([teamId, userId])
  @@index([teamId])
  @@index([userId])
}

model TeamInvitation {
  id        String   @id @default(cuid())
  email     String
  role      String   @default("MEMBER")
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  teamId String
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  invitedById String
  invitedBy   User   @relation(fields: [invitedById], references: [id])

  @@index([teamId])
  @@index([email])
  @@index([token])
}

// ==================== Application Models ====================

model Tunnel {
  id          String    @id @default(cuid())
  subdomain   String    @unique
  localPort   Int
  localHost   String    @default("localhost")

  protocol    String    @default("HTTP")
  password    String?
  ipWhitelist String?

  isActive    Boolean   @default(true)
  expiresAt   DateTime?
  inspect     Boolean   @default(true)

  totalRequests Int     @default(0)
  totalBytes    BigInt  @default(0)

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  lastActiveAt DateTime @default(now())

  // User association (optional for backward compatibility)
  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Team association (optional)
  teamId String?
  team   Team?   @relation(fields: [teamId], references: [id], onDelete: SetNull)

  requests Request[]

  @@index([subdomain])
  @@index([isActive])
  @@index([userId])
  @@index([teamId])
}

model Request {
  id       String @id @default(cuid())
  tunnelId String
  tunnel   Tunnel @relation(fields: [tunnelId], references: [id], onDelete: Cascade)

  method  String
  path    String
  headers String
  body    String?
  query   String?

  statusCode      Int?
  responseHeaders String?
  responseBody    String?
  responseTime    Int?

  ip        String?
  userAgent String?

  createdAt DateTime @default(now())

  @@index([tunnelId])
  @@index([createdAt])
}

model Settings {
  id String @id @default("default")

  // General
  defaultPort       Int     @default(3000)
  defaultSubdomain  String  @default("")
  autoReconnect     Boolean @default(true)
  keepHistory       Int     @default(7)
  maxRequests       Int     @default(1000)

  // Security
  requirePassword     Boolean @default(false)
  defaultExpiration   String  @default("never")
  rateLimit           Int     @default(100)

  updatedAt DateTime @updatedAt
}

model ApiKey {
  id        String    @id @default(cuid())
  name      String
  key       String    @unique
  keyPrefix String    @default("") // First 8 chars for display

  isActive   Boolean   @default(true)
  expiresAt  DateTime?
  createdAt  DateTime  @default(now())
  lastUsedAt DateTime?

  // User association
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([key])
  @@index([userId])
}
